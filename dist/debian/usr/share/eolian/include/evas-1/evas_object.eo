import evas_types;

abstract Evas.Object (Eo.Base, Evas.Common_Interface, Efl.Gfx.Base, Efl.Gfx.Stack)
{
   eo_prefix: evas_obj;
   data: Evas_Object_Protected_Data;
   methods {
      @property size_hint_max {
         set {
            [[Sets the hints for an object's maximum size.

              This is not a size enforcement in any way, it's just a hint
              that should be used whenever appropriate.

              Values -1 will be treated as unset hint components, when
              queried by managers.

              Note: Smart objects (such as elementary) can have their own
              size hint policy. So calling this API may or may not affect
              the size of smart objects.
            ]]
            /* FIXME-doc
            Example:
            @dontinclude evas-hints.c
            @skip evas_object_size_hint_max_set
            @until return

            In this example the maximum size hints change the behavior of an
            Evas box when layouting its children. See the full @ref
            Example_Evas_Size_Hints "example".
            */
         }
         get {
            [[Retrieves the hints for an object's maximum size.

              These are hints on the maximum sizes $obj should have. This is
              not a size enforcement in any way, it's just a hint that
              should be used whenever appropriate.

              Note: Use $null pointers on the hint components you're not
              interested in: they'll be ignored by the function.
            ]]
         }
         values {
            w: Evas.Coord; [[Integer to use as the maximum width hint.]]
            h: Evas.Coord; [[Integer to use as the maximum height hint.]]
         }
      }
      @property size_hint_request {
         set {
            [[Sets the hints for an object's optimum size.

              This is not a size enforcement in any way, it's just a hint
              that hould be used whenever appropriate.

              Values 0 will be treated as unset hint components, when
              queried by managers.

              Note: Smart objects(such as elementary) can have their own
              size hint policy. So calling this API may or may not affect
              the size of smart objects.
            ]]
         }
         get {
            [[Retrieves the hints for an object's optimum size.

              These are hints on the optimum sizes $obj should have.
              This is not a size enforcement in any way, it's just a hint
              that should be used whenever appropriate.

              Note: Use $null pointers on the hint components you're not
              interested in: they'll be ignored by the function.
            ]]
         }
         values {
            w: Evas.Coord; [[Integer to use as the preferred width hint.]]
            h: Evas.Coord; [[Integer to use as the preferred height hint.]]
         }
      }
      @property type {
         set {
            [[Sets the type of the given Evas object.]]
            legacy: null;
         }
         get {
            [[Retrieves the type of the given Evas object.

              For Evas' builtin types, the return strings will be one of
              "rectangle", "line", "polygon", "text", "textblock" or "image".

              For Evas smart objects (see \@ref Evas_Smart_Group), the name
              of the smart class itself is returned on this call. For the
              built-in smart objects, these names are "EvasObjectSmartClipped"
              for the clipped smart object, "Evas_Object_Box" for the box
              object and "Evas_Object_Table for the table object.
            ]]
            /* FIXME-doc
            Example:
            @dontinclude evas-object-manipulation.c
            @skip d.img = evas_object_image_filled_add(d.canvas);
            @until border on the

            See the full @ref Example_Evas_Object_Manipulation "example".
            */
         }
         values {
            type: const(char)*; [[The type of the object.]]
         }
      }
      @property size_hint_min {
         set {
            [[Sets the hints for an object's minimum size.

              This is not a size enforcement in any way, it's just a hint
              that should be used whenever appropriate.

              Values 0 will be treated as unset hint components, when
              queried by managers.

              Note: Smart objects(such as elementary) can have their own
              size hint policy. So calling this API may or may not affect
              the size of smart objects.
            ]]
            /* FIXME-doc
            Example:
            @dontinclude evas-hints.c
            @skip evas_object_size_hint_min_set
            @until return

            In this example the minimum size hints change the behavior of an
            Evas box when layouting its children. See the full @ref
            Example_Evas_Size_Hints "example".
            */
         }
         get {
            [[Retrieves the hints for an object's minimum size.

              These are hints on the minimum sizes $obj should have. This
              is not a size enforcement in any way, it's just a hint that
              should be used whenever appropriate.

              Note: Use $null pointers on the hint components you're not
              interested in: they'll be ignored by the function.
            ]]
         }
         values {
            w: Evas.Coord; [[Integer to use as the minimum width hint.]]
            h: Evas.Coord; [[Integer to use as the minimum height hint.]]
         }
      }
      @property pointer_mode {
         set {
            [[Set pointer behavior.

              This function has direct effect on event callbacks related to
              mouse.

              If $setting is EVAS_OBJECT_POINTER_MODE_AUTOGRAB, then when
              mouse is down at this object, events will be restricted to
              it as source, mouse moves, for example, will be emitted even
              if outside this object area.

              If $setting is EVAS_OBJECT_POINTER_MODE_NOGRAB, then events
              will be emitted just when inside this object area.

              The default value is EVAS_OBJECT_POINTER_MODE_AUTOGRAB.
            ]]
         }
         get {
            [[Determine how pointer will behave.]]
         }
         values {
            pointer_mode: Evas.Object_Pointer_Mode; [[Desired behavior.]]
         }
      }
      @property render_op {
         set {
            [[Sets the render mode to be used for compositing the Evas object.

              Note that only copy and blend modes are actually supported:
              - @Evas.Render_Op.blend means the object will be merged on top of
                objects below it using simple alpha compositing.
              - @Evas.Render_Op.copy means this object's pixels will replace
                everything that is below, making this object opaque.

              Please do not assume that @Evas.Render_Op.copy mode can be used
              to "poke" holes in a window (to see through it), as only the
              compositor can ensure that. Copy mode should only be used with
              otherwise opaque widgets, or inside non-window surfaces (eg. a
              transparent background inside an Ecore.Evas.Buffer).
            ]]
         }
         get {
            [[Retrieves the current value of the operation used for
              rendering the Evas object.
            ]]
         }
         values {
            render_op: Evas.Render_Op; [[One of the Evas_Render_Op values.
                                         Only blend (default) and copy modes
                                         are supported.]]
         }
      }
      @property freeze_events {
         set {
            [[Set whether an Evas object is to freeze (discard) events.

              If $freeze is $true, it will make events on $obj to be
              discarded. Unlike @.pass_events.set, events will not be
              passed to next lower object. This API can be used for
              blocking events while $obj is on transiting.

              If $freeze is $false, events will be processed on that
              object as normal.
            
              Warning: If you block only key/mouse up events with this API,
              we won't guarantee the state of the object, that only had
              key/mouse down events, will be.

              @since 1.1
            ]]
         }
         get {
            [[Determine whether an object is set to freeze (discard) events.

              @since 1.1
            ]]
         }
         values {
            freeze: bool; [[Pass when $obj is to freeze events ($true)
                            or not ($false).]]
         }
      }
      @property map {
         set {
            [[Set current object transformation map.

              This sets the map on a given object. It is copied from the
              $map pointer, so there is no need to keep the $map object if
              you don't need it anymore.

              A map is a set of 4 points which have canvas x, y coordinates
              per point, with an optional z point value as a hint for
              perspective correction, if it is available. As well each
              point has u and v coordinates. These are like "texture
              coordinates" in OpenGL in that they define a point in the
              source image that is mapped to that map vertex/point. The u
              corresponds to the x coordinate of this mapped point and v,
              the y coordinate. Note that these coordinates describe a
              bounding region to sample.

              Note: The map points a uv coordinates match the image geometry.
              If the $map parameter is $null, the stored map will be freed
              and geometry prior to enabling/setting a map will be restored.
            ]]
            /* FIXME-doc
              If you have a 200x100 source
              image and want to display it at 200x100 with proper pixel
              precision, then do:

            @code
            Evas_Map *m = evas_map_new(4);
            evas_map_point_coord_set(m, 0,   0,   0, 0);
            evas_map_point_coord_set(m, 1, 200,   0, 0);
            evas_map_point_coord_set(m, 2, 200, 100, 0);
            evas_map_point_coord_set(m, 3,   0, 100, 0);
            evas_map_point_image_uv_set(m, 0,   0,   0);
            evas_map_point_image_uv_set(m, 1, 200,   0);
            evas_map_point_image_uv_set(m, 2, 200, 100);
            evas_map_point_image_uv_set(m, 3,   0, 100);
            evas_object_map_set(obj, m);
            evas_map_free(m);
            @endcode
            */
         }
         get {
            [[Get current object transformation map.

              This returns the current internal map set on the indicated
              object. It is intended for read-only access and is only
              valid as long as the object is not deleted or the map on
              the object is not changed. 
            ]]
            /* FIXME-doc
              If you wish to modify the map
              and set it back do the following:

            @code
            const Evas_Map *m = evas_object_map_get(obj);
            Evas_Map *m2 = evas_map_dup(m);
            evas_map_util_rotate(m2, 30.0, 0, 0);
            evas_object_map_set(obj, m2);
            evas_map_free(m2);
            @endcode
            */
         }
         values {
            map: const(Evas.Map)*; [[The map.]]
         }
      }
      @property size_hint_aspect {
         set {
            [[Sets the hints for an object's aspect ratio.

              This is not a size enforcement in any way, it's just a hint
              that should be used whenever appropriate.

              If any of the given aspect ratio terms are 0, the object's
              container will ignore the aspect and scale $obj to occupy
              the whole available area, for any given policy.

              Note: Smart objects(such as elementary) can have their own
              size hint policy. So calling this API may or may not affect
              the size of smart objects.
            ]]
         }
         get {
            [[Retrieves the hints for an object's aspect ratio.

              The different aspect ratio policies are documented in the
              #Evas_Aspect_Control type. A container respecting these size
              hints would resize its children accordingly to those policies.

              For any policy, if any of the given aspect ratio terms are 0,
              the object's container should ignore the aspect and scale $obj
              to occupy the whole available area. If they are both positive
              integers, that proportion will be respected, under each
              scaling policy.

              Note: Use $null pointers on the hint components you're not
              interested in: they'll be ignored by the function.
            ]]
            /* FIXME-doc
            These images illustrate some of the #Evas_Aspect_Control policies:

            @image html any-policy.png
            @image rtf any-policy.png
            @image latex any-policy.eps

            @image html aspect-control-none-neither.png
            @image rtf aspect-control-none-neither.png
            @image latex aspect-control-none-neither.eps

            @image html aspect-control-both.png
            @image rtf aspect-control-both.png
            @image latex aspect-control-both.eps

            @image html aspect-control-horizontal.png
            @image rtf aspect-control-horizontal.png
            @image latex aspect-control-horizontal.eps

            This is not a size enforcement in any way, it's just a hint that
            should be used whenever appropriate.
            ---
            Example:
            @dontinclude evas-aspect-hints.c
            @skip if (strcmp(ev->key, "c") == 0)
            @until }

            See the full @ref Example_Evas_Aspect_Hints "example".
            */
         }
         values {
            aspect: Evas.Aspect_Control; [[The policy/type of aspect ratio to apply to $obj.]]
            w: Evas.Coord; [[Integer to use as aspect width ratio term.]]
            h: Evas.Coord; [[Integer to use as aspect height ratio term.]]
         }
      }
      @property clip {
         set {
            [[Clip one object to another.

              This function will clip the object $obj to the area occupied
              by the object $clip. This means the object $obj will only be
              visible within the area occupied by the clipping object
              ($clip).

              The color of the object being clipped will be multiplied by
              the color of the clipping one, so the resulting color for the
              former will be "RESULT = (OBJ * CLIP) / (255 * 255)", per color
              element (red, green, blue and alpha).

              Clipping is recursive, so clipping objects may be clipped by
              others, and their color will in term be multiplied. You may
              not set up circular clipping lists (i.e. object 1 clips
              object 2, which clips object 1): the behavior of Evas is
              undefined in this case.

              Objects which do not clip others are visible in the canvas as
              normal; those that clip one or more objects become invisible
              themselves, only affecting what they clip. If an object ceases
              to have other objects being clipped by it, it will become
              visible again.

              The visibility of an object affects the objects that are
              clipped by it, so if the object clipping others is not shown
              (as in \@ref evas_object_show), the objects clipped by it will
              not be shown  either.

              If $obj was being clipped by another object when this function
              is  called, it gets implicitly removed from the old clipper's
              domain and is made now to be clipped by its new clipper.

              Note: At the moment the only objects that can validly be used
              to clip other objects are rectangle objects. All other object
              types are invalid and the result of using them is undefined.
              The clip object $clip must be a valid object, but can also be
              $null, in which case the effect of this function is the same
              as @.clip_unset on the $obj object.
            ]]
            /* FIXME-doc
            The following figure illustrates some clipping in Evas:

            @image html clipping.png
            @image rtf clipping.png
            @image latex clipping.eps
            ---
            Example:
            @dontinclude evas-object-manipulation.c
            @skip solid white clipper (note that it's the default color for a
            @until evas_object_show(d.clipper);

            See the full @ref Example_Evas_Object_Manipulation "example".
            */
         }
         get {
            [[Get the object clipping $obj (if any).

              This function returns the object clipping $obj. If $obj is
              not being clipped at all, $null is returned. The object $obj
              must be a valid Evas_Object.
            ]]
            /* FIXME-doc
            Example:
            @dontinclude evas-object-manipulation.c
            @skip if (evas_object_clip_get(d.img) == d.clipper)
            @until return

            See the full @ref Example_Evas_Object_Manipulation "example".
            */
         }
         values {
            clip: Evas.Object * @nonull; [[The object to clip $obj by.]]
         }
      }
      @property size_hint_padding {
         set {
            [[Sets the hints for an object's padding space.

              This is not a size enforcement in any way, it's just a hint
              that should be used whenever appropriate.

              Note: Smart objects(such as elementary) can have their own
              size hint policy. So calling this API may or may not affect
              the size of smart objects.
            ]]
         }
         get {
            [[Retrieves the hints for an object's padding space.

              Padding is extra space an object takes on each of its
              delimiting rectangle sides, in canvas units.

              This is not a size enforcement in any way, it's just a hint
              that should be used whenever appropriate.

              Note: Use $null pointers on the hint components you're not
              interested in: they'll be ignored by the function.
            ]]
            /* FIXME-doc
            This space will be rendered
            transparent, naturally, as in the following figure:

            @image html padding-hints.png
            @image rtf padding-hints.png
            @image latex padding-hints.eps
            ---
            Example:
            @dontinclude evas-hints.c
            @skip evas_object_size_hint_padding_set
            @until return

            In this example the padding hints change the behavior of an Evas box
            when layouting its children. See the full @ref
            Example_Evas_Size_Hints "example".
            */
         }
         values {
            l: Evas.Coord; [[Integer to specify left padding.]]
            r: Evas.Coord; [[Integer to specify right padding.]]
            t: Evas.Coord; [[Integer to specify top padding.]]
            b: Evas.Coord; [[Integer to specify bottom padding.]]
         }
      }
      @property repeat_events {
         set {
            [[Set whether an Evas object is to repeat events.

              If $repeat is $true, it will make events on $obj to also be
              repeated for the next lower object in the objects' stack (see
              see \@ref evas_object_below_get).

              If $repeat is $false, events occurring on $obj will be
              processed only on it.
            ]]
            /* FIXME-doc
            Example:
            @dontinclude evas-stacking.c
            @skip if (strcmp(ev->key, "r") == 0)
            @until }

            See the full @ref Example_Evas_Stacking "example".
            */
         }
         get {
            [[Determine whether an object is set to repeat events.]]
         }
         values {
            repeat: bool; [[Whether $obj is to repeat events ($true) or
                            not ($false).]]
         }
      }
      @property size_hint_weight {
         set {
            [[Sets the hints for an object's weight.

              This is not a size enforcement in any way, it's just a hint
              that should be used whenever appropriate.

              This is a hint on how a container object should resize a given
              child within its area. Containers may adhere to the simpler
              logic of just expanding the child object's dimensions to fit
              its own (see the #EVAS_HINT_EXPAND helper weight macro) or
              the complete one of taking each child's weight hint as real
              weights to how much of its size to allocate for them in each
              axis. A container is supposed to, after normalizing the
              weights of its children (with weight  hints), distribut
              the space it has to layout them by those factors -- most
              weighted children get larger in this process than the least
              ones.

              Note: Default weight hint values are 0.0, for both axis.
            ]]
            /* FIXME-doc
            Example:
            @dontinclude evas-hints.c
            @skip evas_object_size_hint_weight_set
            @until return

            In this example the weight hints change the behavior of an Evas box
            when layouting its children. See the full @ref
            Example_Evas_Size_Hints "example".
            */
         }
         get {
            [[Retrieves the hints for an object's weight.

              Accepted values are zero or positive values. Some users might
              use this hint as a boolean, but some might consider it as a
              proportion, see documentation of possible users, which in
              Evas are the \@ref Evas_Object_Box "box" and
              \@ref Evas_Object_Table "table" smart objects.

              This is not a size enforcement in any way, it's just a hint
              that should be used whenever appropriate.

              Note: Use $null pointers on the hint components you're not
              interested in: they'll be ignored by the function.

              Note: If $obj is invalid, then the hint components will be
              set with 0.0.
            ]]
         }
         values {
            x: double; [[Non-negative double value to use as horizontal weight hint.]]
            y: double; [[Non-negative double value to use as vertical weight hint.]]
         }
      }
      @property name {
         set {
            [[Sets the name of the given Evas object to the given name.

              There might be occasions where one would like to name his/her
              objects.
            ]]
            /* FIXME-doc
            Example:
            @dontinclude evas-events.c
            @skip d.bg = evas_object_rectangle_add(d.canvas);
            @until evas_object_name_set(d.bg, "our dear rectangle");

            See the full @ref Example_Evas_Events "example".
            */
         }
         get {
            [[Retrieves the name of the given Evas object.

              Return: The name of the object or $null, if no name has been
              given to it.
            ]]
            /* FIXME-doc
            Example:
            @dontinclude evas-events.c
            @skip fprintf(stdout, "An object got focused: %s\n",
            @until evas_focus_get

            See the full @ref Example_Evas_Events "example".
            */
         }
         values {
            name: const(char)*; [[The given name.]]
         }
      }
      @property scale {
         set {
            [[Sets the scaling factor for an Evas object. Does not affect
              all objects.

              This will multiply the object's dimension by the given factor,
              thus altering its geometry (width and height). Useful when
              you want scalable UI elements, possibly at run time.

              Note: Only text and textblock objects have scaling change
              handlers. Other objects won't change visually on this call.
            ]]
         }
         get {
            [[Retrieves the scaling factor for the given Evas object.]]
         }
         values {
            scale: double; [[The scaling factor. 1.0 means no scaling,
                             default size.]]
         }
      }
      @property static_clip {
         set {
            [[Set a hint flag on the given Evas object that it's used as a
              "static clipper".

              This is a hint to Evas that this object is used as a big
              static clipper and shouldn't be moved with children and
              otherwise considered specially. The default value for new
              objects is $false.
            ]]
         }
         get {
            [[Get the "static clipper" hint flag for a given Evas object.]]
         }
         values {
            is_static_clip: bool; [[$true if it's to be used as a static
                                    clipper, $false otherwise.]]
         }
      }
      @property focus {
         set {
            [[Sets or unsets a given object as the currently focused one on
              its canvas.

              Changing focus only affects where (key) input events go.
              There can be only one object focused at any time. If $focus
              is $true, $obj will be set as the currently focused object
              and it will receive all keyboard events that are not
              exclusive key grabs on other objects.

              See also @.key_grab, @.key_ungrab.
            ]]
            /* FIXME-doc
            Example:
            @dontinclude evas-events.c
            @skip evas_object_focus_set
            @until evas_object_focus_set

            See the full example @ref Example_Evas_Events "here".
            */
         }
         get {
            [[Retrieve whether an object has the focus.

              If the passed object is the currently focused one, $true is
              returned. $false is returned, otherwise.
            ]]
            /* FIXME-doc
            Example:
            @dontinclude evas-events.c
            @skip And again
            @until something is bad

            See the full example @ref Example_Evas_Events "here".
            */
         }
         values {
            focus: bool; [[$true when set as focused or $false otherwise.]]
         }
      }
      @property is_frame_object {
         set {
            [[@since 1.2]]
         }
         get {
            [[@since 1.2]]
         }
         values {
            is_frame: bool;
         }
      }
      @property map_enable {
         set {
            [[Enable or disable the map that is set.

              Enable or disable the use of map for the object $obj. On
              enable, the object geometry will be saved, and the new
              geometry will change (position and size) to reflect the
              map geometry set.

              If the object doesn't have a map set (with
              \@ref evas_object_map_set), the initial geometry will be
              undefined. It is advised to always set a map to the object
              first, and then call this function to enable its use.
            ]]
         }
         get {
            [[Get the map enabled state

              This returns the currently enabled state of the map on the
              object indicated. The default map enable state is off. You
              can enable and disable it with @.map_enable.set.
            ]]
         }
         values {
            enabled: bool; [[Enabled state.]]
         }
      }
      @property precise_is_inside {
         set {
            [[Set whether to use precise (usually expensive) point collision
              detection for a given Evas object.

              Use this function to make Evas treat objects' transparent
              areas as not belonging to it with regard to mouse pointer
              events. By default, all of the object's boundary rectangle
              will be taken in account for them.

              Warning: By using precise point collision detection you'll be
              making Evas more resource intensive.
            ]]
            /* FIXME-doc
            Example code follows.
            @dontinclude evas-events.c
            @skip if (strcmp(ev->key, "p") == 0)
            @until }

            See the full example @ref Example_Evas_Events "here".
            */
         }
         get {
            [[Determine whether an object is set to use precise point
              collision detection.
            ]]
         }
         values {
            precise: bool; [[Whether to use precise point collision
                             detection or not. The default value is false.]]
         }
      }
      @property size_hint_align {
         set {
            [[Sets the hints for an object's alignment.

              These are hints on how to align an object inside the
              boundaries of a container/manager. Accepted values are in
              the 0.0 to 1.0 range, with the special value #EVAS_HINT_FILL
              used to specify "justify" or "fill" by some users. In this
              case, maximum size hints should be enforced with higher
              priority, if they are set. Also, any padding hint set on
              objects should add up to the alignment space on the final
              scene composition.

              See documentation of possible users: in Evas, they are the
              \@ref Evas_Object_Box "box" and \@ref Evas_Object_Table "table"
              smart objects.

              For the horizontal component, 0.0 means to the left, 1.0
              means to the right. Analogously, for the vertical component,
              0.0 to the top, 1.0 means to the bottom.

              This is not a size enforcement in any way, it's just a hint
              that should be used whenever appropriate.

              Note: Default alignment hint values are 0.5, for both axis.
            ]]
            /* FIXME-doc
            See the following figure:

            @image html alignment-hints.png
            @image rtf alignment-hints.png
            @image latex alignment-hints.eps
            ---
            Example:
            @dontinclude evas-hints.c
            @skip evas_object_size_hint_align_set
            @until return

            In this example the alignment hints change the behavior of an Evas
            box when layouting its children. See the full @ref
            Example_Evas_Size_Hints "example".
            */
         }
         get {
            [[Retrieves the hints for on object's alignment.

              This is not a size enforcement in any way, it's just a hint
              that should be used whenever appropriate.

              Note: Use $null pointers on the hint components you're not
              interested in: they'll be ignored by the function.

              Note: If $obj is invalid, then the hint components will be
              set with 0.5
            ]]
         }
         values {
            x: double; [[Double, ranging from 0.0 to 1.0 or with the special value
                         #EVAS_HINT_FILL, to use as horizontal alignment hint.]]
            y: double; [[Double, ranging from 0.0 to 1.0 or with the special value
                         #EVAS_HINT_FILL, to use as vertical alignment hint.]]
         }
      }
      @property propagate_events {
         set {
            [[Set whether events on a smart object's member should get
              propagated up to its parent.

              This function has no effect if $obj is not a member of a
              smart object.

              If $prop is $true, events occurring on this object will be
              propagated on to the smart object of which $obj is a member.
              If $prop is $false, events occurring on this object will not
              be propagated on to the smart object of which $obj is a
              member. The default value is $true.

              See also @.repeat_events.set, @.pass_events.set,
              @.freeze_events.set.
            ]]
         }
         get {
            [[Retrieve whether an Evas object is set to propagate events.

              See also @.repeat_events.get, @.pass_events.get,
              @.freeze_events.get.
            ]]
         }
         values {
            propagate: bool; [[Whether to propagate events ($true) or not
                               ($false).]]
         }
      }
      @property pass_events {
         set {
            [[Set whether an Evas object is to pass (ignore) events.

              If $pass is $true, it will make events on $obj to be ignored.
              They will be triggered on the next lower object (that is not
              set to pass events), instead (see \@ref evas_object_below_get).

              If $pass is $false, events will be processed on that object
              as normal.

              See also @.repeat_events.set, @.propagate_events.set,
              @.freeze_events.set.
            ]]
         }
         get {
            [[Determine whether an object is set to pass (ignore) events.

              See also @.repeat_events.get, @.propagate_events.get,
              @.freeze_events.get.
            ]]
            /* FIXME-doc
            Example:
            @dontinclude evas-stacking.c
            @skip if (strcmp(ev->key, "p") == 0)
            @until }

            See the full @ref Example_Evas_Stacking "example".
            */
         }
         values {
            pass: bool; [[Whether $obj is to pass events ($true) or not
                         ($false).]]
         }
      }
      @property anti_alias {
         set {
            [[Sets whether or not the given Evas object is to be drawn
              anti-aliased.
            ]]
         }
         get {
            [[Retrieves whether or not the given Evas object is to be drawn
              anti_aliased.
            ]]
         }
         values {
            anti_alias: bool; [[$true if the object is to be anti_aliased,
                                $false otherwise.]]
         }
      }
      @property smart_data {
         get {
            [[Retrieve user data stored on a given smart object.]]
            return: void * @warn_unused; [[A pointer to data or $null.]]
         }
      }
      @property smart_clipped_clipper {
         get {
            [[Get the clipper object for the given clipped smart object.

              Use this function if you want to change any of this clipper's
              properties, like colors.
            ]]
            return: Evas.Object * @warn_unused;
         }
      }
      @property clipees {
         get {
            [[Return a list of objects currently clipped by $obj.

              This returns the internal list handle that contains all
              objects clipped by the object $obj. If none are clipped by
              it, the call returns $null. This list is only valid until
              the clip list is changed and should be fetched again with
              another call to this function if any objects being clipped
              by this object are unclipped, clipped by a new object,
              deleted or get the clipper deleted. These operations will
              invalidate the list returned, so it should not be used
              anymore after that point. Any use of the list after this
              may have undefined results, possibly leading to crashes.
              The object $obj must be a valid Evas_Object.

              See also @.clip.set, @.clip_unset and @.clip.get.
            ]]
            /* FIXME-doc
            Example:
            @code
            extern Evas_Object *obj;
            Evas_Object *clipper;

            clipper = evas_object_clip_get(obj);
            if (clipper)
            {
            Eina_List *clippees, *l;
            Evas_Object *obj_tmp;

            clippees = evas_object_clipees_get(clipper);
            printf("Clipper clips %i objects\n", eina_list_count(clippees));
            EINA_LIST_FOREACH(clippees, l, obj_tmp)
            evas_object_show(obj_tmp);
            }
            @endcode */
            return: const(list<Evas.Object*>)* @warn_unused; [[A list of objects being clipped by $obj.]]
         }
      }
      @property smart_parent {
         get {
            [[Gets the parent smart object of a given Evas object, if it
              has one.
            ]]
            return: Evas.Object * @warn_unused; [[The parent smart object
                                                  of $obj or $null.]]
         }
      }
      @property size_hint_display_mode {
         get {
            [[Retrieves the hints for an object's display mode

              These are hints on the display mode $obj. This is not a size
              enforcement in any way, it's just a hint that can be used
              whenever appropriate. This mode can be used object's display
              mode like commpress or expand.
            ]]
         }
         set {
            [[Sets the hints for an object's disply mode,

              This is not a size enforcement in any way, it's just a hint
              that can be used whenever appropriate.
            ]]
         }
         values {
            dispmode: Evas.Display_Mode; [[Display mode hint.]]
         }
      }
      @property paragraph_direction {
         [[This handles text paragraph direction of the given object.
           Even if the given object is not textblock or text, its smart child objects
           can inherit the paragraph direction from the given object.
           The default paragraph direction is @Evas.BiDi_Direction.inherit.]]
         set {
         }
         get {
         }
         values {
            dir: Evas.BiDi_Direction; [[Paragraph direction for the given object.]]
         }
      }
      clipees_has @const {
         [[Test if any object is clipped by $obj.

           @since 1.8
         ]]
         return: bool @warn_unused;
      }
      key_grab {
         [[Requests $keyname key events be directed to $obj.

           Key grabs allow one or more objects to receive key events for
           specific key strokes even if other objects have focus. Whenever
           a key is grabbed, only the objects grabbing it will get the
           events for the given keys.

           $keyname is a platform dependent symbolic name for the key
           pressed (see \@ref Evas_Keys for more information).

           $modifiers and $not_modifiers are bit masks of all the
           modifiers that must and mustn't, respectively, be pressed along
           with $keyname key in order to trigger this new key grab.
           Modifiers can be things such as Shift and Ctrl as well as
           user defined types via \@ref evas_key_modifier_add. Retrieve
           them with \@ref evas_key_modifier_mask_get or use 0 for empty
           masks.

           $exclusive will make the given object the only one permitted to
           grab the given key. If given $true, subsequent calls on this
           function with different $obj arguments will fail, unless the key
           is ungrabbed again.

           Warning: Providing impossible modifier sets creates undefined
           behavior.

           See also @.key_ungrab, @.focus.get, @.focus.set,
           \@ref evas_focus_get, \@ref evas_key_modifier_add.
         ]]
         /* FIXME-doc
         Example code follows.
         @dontinclude evas-events.c
         @skip if (d.focus)
         @until else

         See the full example @ref Example_Evas_Events "here".
         */

         return: bool @warn_unused; [[$true if the call succeeded, $false otherwise.]]
         params {
            @in keyname: const(char)* @nonull; [[The key to request events for.]]
            @in modifiers: Evas.Modifier_Mask; [[A mask of modifiers that must be
                                                present to trigger the event.]]
            @in not_modifiers: Evas.Modifier_Mask; [[A mask of modifiers that must
                                                     not be present to trigger the event.]]
            @in exclusive: bool; [[Request that the $obj is the only object
                                   receiving the $keyname events.]]
         }
      }
      smart_type_check @const {
         [[Checks whether a given smart object or any of its smart object
           parents is of a given smart class.

           If $obj is not a smart object, this call will fail immediately.

           This function supports Eo and legacy inheritance mechanisms.
           However, it is recommended to use \@ref eo_isa instead if your
           object is using Eo from top to bottom.

           The checks use smart classes names and string comparison. There
           is a version of this same check using pointer comparison, since
           a smart class' name is a single string in Evas.

           See also @.smart_type_check_ptr.
         ]]
         return: bool @warn_unused;
         params {
            @in type: const(char)* @nonull; [[The name (type) of the smart class to check for.]]
         }
      }
      name_child_find @const {
         [[Retrieves the object from children of the given object with the
           given name.

           This looks for the evas object given a name by @.name.set, but
           it ONLY looks at the children of the object *p obj, and will
           only recurse into those children if $recurse is greater than 0.
           If the name is not unique within immediate children (or the whole
           child tree) then it is not defined which child object will be
           returned. If $recurse is set to -1 then it will recurse without
           limit.

           @since 1.2
         ]]
         return: Evas.Object * @warn_unused; [[The Evas object with the given name
                                               on success, Otherwise $null.]]
         params {
            @in name: const(char)*; [[The given name.]]
            @in recurse: int; [[
               Set to the number of child levels to recurse (0 == don't
               recurse, 1 == only look at the children of $obj or their
               immediate children, but no further etc.).
            ]]
         }
      }
      key_ungrab {
         [[Removes the grab on $keyname key events by $obj.

           Removes a key grab on $obj if $keyname, $modifiers, and
           $not_modifiers match.

           See also @.key_grab, @.focus.get, @.focus.set,
           \@ref evas_focus_get.
         ]]
         /* FIXME-doc
         Example code follows.
         @dontinclude evas-events.c
         @skip got here by key grabs
         @until }

         See the full example @ref Example_Evas_Events "here".
         */
         params {
            @in keyname: const(char)* @nonull; [[he key the grab is set for.]]
            @in modifiers: Evas.Modifier_Mask; [[A mask of modifiers that must be
                                                 present to trigger the event.]]
            @in not_modifiers: Evas.Modifier_Mask; [[A mask of modifiers that mus
                                                     not not be present to trigger
                                                     the event.
                                                   ]]
         }
      }
      clip_unset {
         [[Disable/cease clipping on a clipped $obj object.

           This function disables clipping for the object $obj, if it was
           already clipped, i.e., its visibility and color get detached from
           the previous clipper. If it wasn't, this has no effect. The
           object $obj must be a valid Evas_Object.

           See also @.clip.set, @.clipees.get and @.clip.get.
         ]]
      }
      smart_move_children_relative {
         [[Moves all children objects of a given smart object relative to a
           given offset.

           This will make each of $obj object's children to move, from where
           they before, with those delta values (offsets) on both directions.

           Note: This is most useful on custom smart $move functions.

           Note: Clipped smart objects already make use of this function on
           their $move smart function definition.
         ]]
         params {
            @in dx: Evas.Coord; [[Horizontal offset (delta).]]
            @in dy: Evas.Coord; [[Vertical offset (delta).]]
         }
      }
      smart_type_check_ptr @const {
         [[Checks whether a given smart object or any of its smart object
           parents is of a given smart class, using pointer comparison.
         ]]
         return: bool @warn_unused; [[$true if $obj or any of its parents
                                      is of type $type, $false otherwise.]]
         params {
            @in type: const(char)* @nonull; [[The type (name string) to check for. Must be the name.]]
         }
      }
      @property no_render {
         get {
            [[Returns the state of the "no-render" flag, which means, when
              true, that an object should never be rendered on the canvas.

              This flag can be used to avoid rendering visible clippers on
              the canvas, even if they currently don't clip any object.

              @since 1.15
            ]]
            legacy: null;
         }
         set {
            [[Disable all rendering on the canvas.

              This flag will be used to indicate to Evas that this object
              should never be rendered on the canvas under any
              circurmstances. In particular, this is useful to avoid
              drawing clipper objects (or masks) even when they don't
              clip any object. This can also be used to replace the old
              source_visible flag with proxy objects.

              This is different to the visible property, as even visible
              objects marked as "no-render" will never appear on screen.
              But those objects can still be used as proxy sources or
              clippers. When hidden, all "no-render" objects will
              completely disappear from the canvas, and hide their
              clippees or be invisible when used as proxy sources.

              @since 1.15
            ]]
            legacy: null;
         }
         values {
            enable: bool; [[Enable "no-render" mode.]]
         }
      }
   }
   implements {
      Eo.Base.constructor;
      Eo.Base.destructor;
      Eo.Base.dbg_info_get;
      Evas.Common_Interface.evas.get;
      Efl.Gfx.Base.visible.set;
      Efl.Gfx.Base.visible.get;
      Efl.Gfx.Base.position.set;
      Efl.Gfx.Base.position.get;
      Efl.Gfx.Base.color.set;
      Efl.Gfx.Base.color.get;
      Efl.Gfx.Base.color_part.set;
      Efl.Gfx.Base.color_part.get;
      Efl.Gfx.Base.size.set;
      Efl.Gfx.Base.size.get;
      Efl.Gfx.Stack.layer.set;
      Efl.Gfx.Stack.layer.get;
      Efl.Gfx.Stack.below.get;
      Efl.Gfx.Stack.above.get;
      Efl.Gfx.Stack.stack_below;
      Efl.Gfx.Stack.stack_above;
      Efl.Gfx.Stack.raise;
      Efl.Gfx.Stack.lower;
   }
   events {
       mouse,in; [[Mouse In Event ]]
       mouse,out; [[Mouse Out Event ]]
       mouse,down; [[Mouse Button Down Event ]]
       mouse,up; [[Mouse Button Up Event ]]
       mouse,move; [[Mouse Move Event ]]
       mouse,wheel; [[Mouse Wheel Event ]]
       multi,down; [[Mouse-touch Down Event ]]
       multi,up; [[Mouse-touch Up Event ]]
       multi,move; [[Multi-touch Move Event ]]
       free; [[Object Being Freed (Called after Del) ]]
       key,down; [[Key Press Event ]]
       key,up; [[Key Release Event ]]
       focus,in; [[Focus In Event ]]
       focus,out; [[Focus Out Event ]]
       show; [[Show Event ]]
       hide; [[Hide Event ]]
       move; [[Move Event ]]
       resize; [[Resize Event ]]
       restack; [[Restack Event ]]
       del; [[Object Being Deleted (called before Free) ]]
       hold; [[Events go on/off hold ]]
       changed,size,hints; [[Size hints changed event ]]
       image,preloaded; [[Image has been preloaded ]]
       image,resize; [[Image resize ]]
       image,unloaded; [[Image data has been unloaded (by some mechanism in
                         Evas that throw out original image data)]]
   }
}
